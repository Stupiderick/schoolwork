### ch4-p1
you can use malloc() or static variables
e.g. int var = malloc(128)
e.g. static int var = ??

### ch4-p2
stack memory has a faster access speed, and it is allocated when the program is compiled;
heap memory has a slower access speed, and it is allocated during the runtime of the program.

### ch4-p3
nope

### ch4-p4
"In a good C program, for every malloc, there is a free".

### ch4-p5
malloc() may fail when there is no enough heap memory

### ch4-p6
time() returns a time_t format time; but ctime() returns a C string of the info of time.

### ch4-p7
it double free'd the same pointer.

### ch4-p8
it used the free'd pointer, which can be invalid.

### ch4-p9
set the free'd pointer to NULL
e.g. ptr = NULL;

### ch4-p10
struct Person {
    char * name;
    int age;
    person_t ** s;
};

typedef struct Person person_t;

### ch4-p11
int main() {
    person_t * as = (person_t*) malloc(sizeof(person_t));
    person_t * sm = (person_t*) malloc(sizeof(person_t));
    as->name = "Agent Smith";
    sm->name = "Sonny Moore";
    as->age = 128;
    sm->age = 256;
    as->s = &sm;
    sm->s = &as;
    free(as);
    as = NULL;
    free(sm);
    sm = NULL;
    return 0;
}


### ch4-p12
person_t * create(char * aName, int anAge) {
    person_t * res = (person_t*) malloc(sizeof(person_t));
    res->name = strdup(aName);
    res->age = anAge;
    res->s = malloc(sizeof(person_t*) * 10);

    return res;
}


### ch4-p13
void destroy(person_t * p) {
    free(p->name);
    free(p->s);
    memset(p, 0, sizeof(person_t));
    free(p);
}
